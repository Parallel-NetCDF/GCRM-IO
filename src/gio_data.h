/*
 *  Copyright (C) 2013, Northwestern University.
 *  See COPYRIGHT notice COPYING in top-level directory.
 *
 *  $Id: gio_data.h 4609 2017-12-07 07:26:38Z wkliao $
 */

#ifndef H_GIO_DATA
#define H_GIO_DATA

#include <gio.h>

/*
 *  data block descriptor
 */
typedef struct {
    /*  Pointers to locally held data */
    int    *integer_data;
    float  *real_data;
    double *double_data;

    /*  what portion of geodesic grid does this block correspond to? */
    int imin, imax, jmin, jmax;
    int panel_id, block_index;
} data_block;

typedef enum {
    int_type = 0, /* 4-byte int */
    flt_type = 1, /* 4-byte float */
    dbl_type = 2  /* 8-byte double */
} elm_type;

typedef struct {
    /*
     *  Required keywords for a data descriptor are
     *
     *       standard_name, data_type, units, long_name
     *
     *  Other keyword/pairs will be treated as other attributes and
     *  those attributes will be tacked on to the field description in netcdf files
     */
    char field_name[128];    /* "keyname" used elsewhere */
    char output_field_name[128];    /* Name to use in netcdf (or other) output generated by this API */
    char standard_name[128]; /* local handle */
    elm_type data_type;    /* int, real, double, etc.  */
    char units[32];
    char long_name[128];     /* description */
    char field_attr_name[MAX_ATTR][32];
    char field_attr_value[MAX_ATTR][128]; 
    char index_dimension_name[MAX_DIMS][32];    /* tempory storage of unknown dimension names */
    int  num_unknown_dims;   /* number of unknown dimensions found in descriptor file */
    int  num_attrs;
    int  num_dims;
    int  field_dims[MAX_DIMS];
    int  parent;        /* Descriptor ID for descriptors that are derived from other descriptors */
    /*  
     * if a user specifies
     *
     *   dimension grid_cells, grid_corners
     *
     * we will define 2 dimensions for the field,
     * and store field_dims as (grid_cells_dim, grid_corners_dim)
     *
     * if the field is non static, the dimensions will become
     *
     *   3 dimensions
     *   field_dims will become (grid_cells_dim, grid_corners_dim, time_dim)
     */
    int  has_levels;   /* Does this data thing have a levels dimension? */
    int  has_endpts;   /* Does this data thing have an endpoints dimension? */
    int  is_vector;    /* Is this data thing a vector quantity? */
    int  is_corner;    /* Is this data thing a corner/face quantity? */
    int  is_restart;   /* Is this a restart quantity? */
    int  is_static;    /* Is this a dynamic (time-varying) quantity or not? */
    int  is_grid;      /* Field represent static grid data */

    int  no_data;      /* Some fields may not have any model data associated
                        * with them. In this situation, set no_data to .TRUE.
                        * otherwise set to .FALSE.
                        */
    int  active;       /* has data been associated with this descriptor? */
    int  is_general;   /* General data layout  */
    int  no_poles;     /* Don't send or write pole data */
    int  assigned;     /* Some data has been assigned to this descriptor */

    int  grid_size;    /* Total number of grid points in output */
    int  imin1, imax1, inc1, ld1;  /* indices for dim im */
    int  imin2, imax2, inc2, ld2;  /* indices for dim jm */
    int  imin3, imax3, inc3, ld3;  /* indices for dim km */
    int  imin4, imax4; /* handle species dim */
    int  stride1, stride2, stride3;
    int  column_size;  /* Total number of data points per grid column */
    int  cell_idx;
    int  time_idx;
    int  intg_idx;
    int  num_file_dims;
    int  file_dims[6];
    char file_dim_names[6][128];
    char raw_dim_names[7][128];
    int  raw_dim_sizes[7];
    int  index_choice;
    /*
     *  number of data blocks held by processor
     */
    int num_data_blocks;  /* number of grid block per processor (1,2 or 5) */

    data_block gio_data_blocks[MAX_DATA_BLOCKS];

    /*
     *  Pole data
     */
    int    *int_south_data;
    int    *int_north_data;
    float  *real_south_data;
    float  *real_north_data;
    double *double_south_data;
    double *double_north_data;
    /*
     *  Flags for level data
     */
    int use_up_direction;
    int use_layers;
    /*
     *  Level data
     */
    float *float_level_data;
    int    is_level_data;

    double record_count;    /* Number of records written to netcdf file for this descriptor */
    double bytes_written;   /* Number of bytes written to netcdf file for this descriptor */
    double bytes_read;      /* Number of bytes read from netcdf file for this descriptor */
    double time_for_writes; /* Seconds spent writing data to netcdf for this descriptor */
    double time_for_reads;  /* Seconds spent reading data from netcdf for this descriptor */
    /*
     *  Data used to for averaging
     */
    int average_data;

    data_block gio_average_data[MAX_DATA_BLOCKS];

    int avg_count;
    float *avg_south_data;
    float *avg_north_data;
    /*
     *  Data used to manage time integration arrays
     */
    /* int index_array */
    int index_cur;
    /*
     * io_buf is used by the I/O subroutines
     */
    void   *io_buf;        /* will type casted to int, float, or double */
    int     allocate_size; /* number of array elements allocated */
} data_descriptor;

typedef struct {
    /*
     * This module contains all the data descriptors for the system
     *

     * known dimension names are:
     *
     *   grid_cells_dim    (computed from resolution as: length * 10 + 2 (where length = 2**resolution)
     *   grid_corners_dim  (a set value of 6)
     *   grid_vectors_dim  (a set value of 3)
     *   grid_levels_dim   (the same as "nlevel")
     *   time_dim          (the "record" or NF_UNLIMITED) dimension.
     *
     *   IN FORTRAN the time dimension must be the last dimension specified.
     *
     *   Specific "tags" to help specify dimensions in netcdf files we generate
     */
    int grid_cells_dim;         /* will generate the cells dimension */
    int grid_vectors_dim;       /* will generate the vector dimension (size = 3) */
    int grid_layers_dim;        /* will generate the layers dimension  */
    int grid_interfaces_dim;    /* will generate the interfaces dimension */
    int grid_all_uniq_crnr_dim; /* will generate the corners (2 * (cells-2)) dimension */
    int grid_all_uniq_edge_dim; /* will generate the edges (3 * (cells-2)) dimension */
    int grid_celledges_dim;     /* will generate the celledges dimension (size = 6) */
    int grid_cellcorners_dim;   /* will generate the cellcorners dimension (size = 6) */
    int grid_endpoints_dim;     /* will generate the endpoints dimension (size = 2) */
    int grid_cellneighbors_dim; /* will generate the cellneighbors dimension (size = 6) */
    int layers_field;
    int interfaces_field;
    int layers_length;
    int interfaces_length;
    int time_dim;

    int have_large_data;        /* Exceeds 32 bit indexing limits */
    int num_grid_flds;          /* total number of static fields describing the grid */

    /* We need to compute an approximate file size to determine if we 
     * need to use CDF2 or CDF5 format
     */
    long long field_size_check;
    /*
     * number of fields that have been defined
     */
    int num_fields;  /* Total number of data descriptors in data.config file */

    /*
     *  Vector of data descriptors
     */
    data_descriptor *gio_descriptors; /* [MAX_DATA_FIELDS] */

    /*
     *  Data needed to set up averages
     */
    int  num_averages;
    int  avg_field_ids[MAX_DATA_FIELDS];

    /*
     *  Miscellaneous data for restart files
     */
    double restart_dbl[100];
    char restart_dbl_names[100][128];
    int num_restart_dbl;

    int restart_int[100];
    char restart_int_names[100][128];
    int num_restart_int;
} gio_data;

#endif
